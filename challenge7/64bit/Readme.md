## Questions

As a complimentary resource, you might want to check out [this stack overflow post](https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-i386-and-x86-6) for 64-bit architecture and [this excellent post](https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64).
### Tertiary

- Compile the code on an 64 bit machine. Analyse the call convention again.

We can fire up a 64 bit container with no ASLR. We compile the code using the make file.

This is what the disassembly looks like:

    gdb-peda$ disas functionMinimal
    Dump of assembler code for function functionAdvanced:
    0x0000000000400526 <+0>:     push   rbp
    0x0000000000400527 <+1>:     mov    rbp,rsp
    0x000000000040052a <+4>:     nop
    0x000000000040052b <+5>:     pop    rbp
    0x000000000040052c <+6>:     ret

Ok, this is very similar to the 32-bit version except ebp and esp are replaced by rbp and rsp
The disassembled code for the functionBasic is similar as well. However, prior to the call instruction, we have:

     mov edi, 0x5

This shows that the argument is stored into a register (rdi) instead of being pushed to the stack. The AMD64 ABI specifies that the first 6 argument are stored in registers and the rest on the stack. You probably want to read the complimentary resources above as the red zone is als explained for leaf functions.
However, it is interesting to note that in some cases, the register value is moved to the stack before operating on it (That is the case in functionBasic and functionAdvanced)
For example in functionBasic:

   0x0000000000400531 <+4>:	mov    DWORD PTR [rbp-0x14],edi ; rdi value stored in stack (Probably inn redzone as a the time rsp = rbp)
   0x0000000000400534 <+7>:	mov    eax,DWORD PTR [rbp-0x14] ; eax = the rdi value (int c)
   0x0000000000400537 <+10>:	add    eax,0x1 ; int c incremented by one
   0x000000000040053a <+13>:	mov    DWORD PTR [rbp-0x4],eax ; int d stored in stack

