## Questions

### Primary


- If the first argument is at EBP+0x8, what is at EBP+0x4 and EBP+0x0? What is at EBP+0xc?

According to the [0X32\_FunctionCallConvention slides](https://exploit.courses/files/bfh2017/day2/0x32_FunctionCallConvention.pdf), ebp+0x8 contains the address where the value of c is stored (pointer), ebp+0x4 contains the saved instruction pointer (SIP) which points to the next instruction eip should take after finishing the function. ebp+0x0 contains the saved frame pointer (sfp). As the stack fram has different sizes depending on the function ,this allows when leaving the function to set the stack pointer back to sfp and clean up the stack (basically poping the stack by sfp-esp).

- Why are arguments referenced with a positive number via EBP (e.g. EBP+0x8), and local variables with a negative number (e.g. EBP-0x4) ? Because ebp=sfp and argument pointers are set before sfp in the stack and local variables after. If we consider functionBasic we have:

High addresses (bottom of stack)
	|&c ; address to value of c
	|SIP; return address (next instruction after function)
	|SFP; = ebp
	|int d ;= esp (except if more arguments are pushed to stack)
Low addresses (top of stack)

- What is the assembly command "leave" doing?
According to the slides, the leave instruction is equivalent to:

mov esp,ebp
pop ebp

This sets esp back to SFP and pops SFP in ebp which means we now have ebp=esp. The stack looks like this after mov esp,ebp:

High addresses (bottom of stack)
	|&c
	|SIP
	|SFP; = ebp=esp
	| old values that can now be replaced
Low addresses(top of stack)

After the pop ebp :

High addresses(bottom of stack)
	|&c
	|SIP; = esp
	| old values that can now be replaces
Low addresses(top of stack)

Finally the ret instruction is equivalent to pop eip. This will send the SIP value (address to the next assembly instruction) into eip

### Secondary

- The code was compiled without any optimization (-O0). What happens if you enable optimization?

The compile time is longer but the binary will usually run faster. We can compile the binary with a first level of optimization. According to the [online documentation](https://gcc.gnu.org/onlinedocs/gnat_ugn/Optimization-Levels.html), the first level of optimization improves code performance without adding much compile time. We can compile the binary with the following:

    $ gcc -o challenge7 challenge7.c -O1 -fno-omit-frame-pointer 

We can then disassemble the code in gdb:

    $ gdb challenge7
    gdb-peda$ disas functionMinimal
    Dump of assembler code for function functionMinimal:
    0x0804840b <+0>:     push   ebp
    0x0804840c <+1>:     mov    ebp,esp
    0x0804840e <+4>:     pop    ebp
    0x0804840f <+5>:     ret 

The nop instruction has been removed.

    gdb-peda$ disas functionBasic
    Dump of assembler code for function functionBasic:
    0x08048410 <+0>:     push   ebp
    0x08048411 <+1>:     mov    ebp,esp
    0x08048413 <+3>:     mov    eax,DWORD PTR [ebp+0x8]
    0x08048416 <+6>:     add    eax,0x1
    0x08048419 <+9>:     pop    ebp
    0x804841a  <+10>:    ret

And so on. Optimization can make the reverse engineering process harder (or easyer) as some instructions are merged or removed.
 
- The code was also compiled with -fno-omit-frame-pointer. What happens if you compile it without this parameter? Why could this be useful?

According to man gcc, the flag is turned on by default in -O0 so we need to remove it from our command with -O1.

The disassembly of functionMinimal returns:

    0x0804840b <+0>:    repz ret

And for functionBasic:

    0x0804840d <+0>:    mov eax,DWORD PTR [esp+0x4]
    0x08048411 <+4>:    add eax,0x1
    0x08048414 <+7>:    ret

We are very quick to notice that all the assembly code handling the SFP switch where we push ebp to stack as SFP at the beginning then SFP poped into ebp at the end (and removed from stack setting esp = SIP) has been removed.There are no function prologue and epilogue. This can be usefull when reverse engineering /debuging code logic as it allows to focus on the logic and remove these not always helpful bits.
