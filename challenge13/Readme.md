## Questions

I used a slightly different method to find where my shellcode was. The  x/32x 0x7fffffffdf08 methode is pretty good. You can change the adress slightly and use x/500x to try and find a NOP sled (\x90) to  find the shellcode, however the easyest way is to set a breakpoint on the call to "handleData" and do x/32x $rdi.

I found 0x7fffffffe0e0 was a working return adress in gdb.

- Can you make the exploit work, if the program is started standalone (without GDB)?

Let's give this a shot! The first thing we notice is that we can't store our shellcode in an environment variable as that would not be realistic ( in a real life scenario, we would not be able to add an env variable on the server). So I thought I might try to store the shellcode in the password variable from the handleData function. However I noticed the binary now had a slightly different logic than the one in challenge12. Only one variable was used in the binary. The second variable was not affected by user input. So we had to keep the exploit in the first variable and were limited to a very small NOPsled. Finding the correct return adress was now the difficult part. Using gdb-peda and unsetting the LINES and COLUMNS variable got me a return adress of 0x7fffffffe100. 

    gdb-peda$: unset env COLUMNS
    gdb-peda$: unset env LINES
    gdb-peda$: set follow-fork-mode child
    gdb-peda$: b *<adress of call handleData instruction>
    gdb-peda$: run

If we did not have the possibility to modify the binary, a simple method to find the adress would be creating a bruteforce script which tries the exploit with different adresses starting at 0x7fffffffe100 decrementing each time the adress and stopping when a connection is open on the server at port 4444. I did not want to bother writing this script so I went for a simpler solution. I modified challenge13.c to print the adress of the username variable.

    printf("Username will be at %p\n", username);


This printed the adress 0x7fffffffdc00 . This is the start of the username string. Looking at the exploit, I noticed the shellcode started at 0x7fffffffdc00 + 27 + 4 as there are 27 "A" letters and a 4 bytes long return adress. I incremented this by 5 just to be sure to land right in the NOP sled and chose 0x7fffffffdc24 as the new return adress.

- Instead of the listener shellcode, can you use a connect-back shellcode?

You can look at the reverse\_shell\_socket.asm file for the classic connect back shellcode. If you want a netcat version, try the reverse\_shell\_socket\_nce.asm . This leverages the nc -e option. 

# TODO:

If you want a netcat shellcode without the -e option, look at the reverse\_shell\_socket\_nc.asm file. This leverages the system() libc function. It drops privileges because it calls /bin/sh, however as Debian based systems run a modified bash version, it is not the case for them.
The system\_nc.c shows the connect back shellcode call in C. The systemaddr.c file allows to pinpoint the system() function's adress in libc and test the reverse shell command.Once compiled with the right options, just run it in gdb, break on the main function, run it and type:

    gdb-peda$:p system()
