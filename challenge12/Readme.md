## Questions

A good extra read on x64 architecture is available [here](https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64).

Sometimes when running my exploit I would get the usage string for some reason. I had to remove the argument check to make it work as shown in challenge12bis.c

I couldn't run this challenge on the container as it would not start for some reason.
So I ran it on my x64 ubuntu and disabled ASLR with:

    echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

I found an offset of 88. And the shellcode adress (first argument of handleData = $rdi)at 0x7fffffffe11d as shown in challenge12-exploit-skel.py


- Can you adjust the exploit so it works without GDB?

I'm pretty sure we can :)

Just like in challenge11 could use the environment method but I wanted to try something new just for the lolz. One possible  other method would be to modify challenge12.c so that it prints it's argument adresses at runtime. Cool, but not what I want.
We can also use the core file method explained in challenge11. However, I could not find where the core file was generated and did not want to bother looking for it.

Finally another method is to remove the extra variables that gdb adds at runtime and try and find the adress like so. There is still an offset but it is smaller
To remove env variables in gdb:

    gdb-peda$: unset env LINES
    gdb-peda$: unset env COLUMNS
    gdb-peda$: show env

The show env command will display all environment variables. We can now set a breakpoint at the call handleData instruction and run the code with our shellcode as argument. We then examine $rdi with: 

    gdb-peda$: x/4x $rdi

I changed the adress slightly (incremented it) and got a shell out of gdb with 0x7fffffffe151 .

- Can you create an exploit which works in both, with and without GDB?

Nope... Can't do it, definitely can't... JK! (such a funny guy).

This is just like challenge11 where we needed to use a pretty huge NOP sled to hit it both in and out of gdb. I set a 2000 long NOP sled, stored the NOP sled + shellcode in an environment variable. Found the address with getenv.c program and got 0x7fffffffe7c9 . I incremented the adress and wrote 0x7fffffffe7d9 in my challenge12-exploit-final.py program. Tested it out of gdb and then in gdb. Both worked. Yay! \(0o0)/

